#!/usr/bin/env python

import os
from jinja2 import Template
import json
import shutil
import argparse
from reactopya import ShellScript, reactopya_templates_directory

def main():
    parser = argparse.ArgumentParser(description='Reactopya command-line utility')
    parser.add_argument('command', help='One of the following: generate | install-electron | start-electron-dev | install-jupyter-extension')

    args = parser.parse_args()
    command = args.command

    config = _load_config()

    if command == 'generate':
        _generate(config=config)
    elif command == 'install-electron':
        _generate(config=config)
        _install_electron(config=config)
    elif command == 'start-electron-dev':
        _generate(config=config)
        _start_electron_dev(config=config)
    elif command == 'install-jupyter-extension':
        _generate(config=config)
        _install_jupyter_extension(config=config)
    else:
        raise Exception('Unknown command: {}'.format(command))

def _install_electron(config):
    cmd = '''
        #!/bin/bash
        set -ex
        cd generated/{extension_name}
        pip install -e .
        yarn install
        yarn install-electron
    '''.format(extension_name=config['extension_name'])
    shell_cmd = ShellScript(cmd)
    shell_cmd.start()
    retcode = shell_cmd.wait()

    if retcode != 0:
        raise Exception('Shell script exited with non-zero return code: {}'.format(retcode))

    print('You may now run "reactopya start-electron-dev".')

def _start_electron_dev(config):
    cmd = '''
        #!/bin/bash
        set -ex
        cd generated/{extension_name}
        yarn electron-dev
    '''.format(extension_name=config['extension_name'])
    shell_cmd = ShellScript(cmd)
    shell_cmd.start()
    retcode = shell_cmd.wait()

    if retcode != 0:
        raise Exception('Shell script exited with non-zero return code: {}'.format(retcode))

def _install_jupyter_extension(config):
    cmd = '''
        #!/bin/bash
        set -ex
        cd generated/{extension_name}
        pip install -e .
        cd ../{extension_name}_jup
        pip install -e .
        yarn install
        yarn install-extension
    '''.format(extension_name=config['extension_name'])
    shell_cmd = ShellScript(cmd)
    shell_cmd.start()
    retcode = shell_cmd.wait()

    if retcode != 0:
        raise Exception('Shell script exited with non-zero return code: {}'.format(retcode))
    
    print('You may now import {}_jup within a jupyter notebook.'.format(config['extension_name']))

def _generate(config):
    print('Reactopya: Generating code...')
    num = _generate_directory(reactopya_templates_directory(), 'generated', config=config)
    print('{} files processed'.format(num))

def _load_config():
    with open('reactopya.config.json', 'r') as f:
        config = json.load(f)
    config['widgets'] = _load_widgets_config()
    config['package_json'] = _load_package_json()
    return config

def _load_widgets_config():
    dirnames = [
        name for name in os.listdir('widgets')
        if os.path.isdir(os.path.join('widgets', name))
    ]
    ret = []
    for dirname in dirnames:
        json_fname = os.path.join('widgets', dirname, dirname+'.json')
        if os.path.exists(json_fname):
            with open(json_fname, 'r') as f:
                widget = json.load(f)
            ret.append(widget)
    return ret

def _load_package_json():
    if os.path.exists('widgets/package.json'):
        with open('widgets/package.json', 'r') as f:
            x = json.load(f)
        return dict(
            dependencies = x.get('dependencies', {})
        )
    else:
        return dict(
            dependencies={}
        )

def _generate_directory(template_source_path, dest_path, config, do_render=True):
    num_files_processed = 0
    fnames = [
        name for name in os.listdir(template_source_path)
        if os.path.isfile(os.path.join(template_source_path, name))
    ]
    fnames_dst = [ _map_file_name(fname, config=config) for fname in fnames]
    dirnames = [
        name for name in os.listdir(template_source_path)
        if os.path.isdir(os.path.join(template_source_path, name))
    ]
    dirnames_dst = [ _map_file_name(dirname, config=config) for dirname in dirnames]

    if len(fnames) == 1 and fnames[0] == '.widgets_go_here':
        return _generate_directory('widgets', dest_path, config, do_render=False)
        
    if not os.path.exists(dest_path):
        os.mkdir(dest_path)

    fnames_existing = [
        name for name in os.listdir(dest_path)
        if os.path.isfile(os.path.join(dest_path, name))
    ]
    dirnames_existing = [
        name for name in os.listdir(dest_path)
        if os.path.isdir(os.path.join(dest_path, name))
    ]

    for fname in fnames_existing:
        if fname not in fnames_dst:
            print('Removing: {}'.format(os.path.join(dest_path, fname)))
            os.remove(os.path.join(dest_path, fname))
    
    for dirname in dirnames_existing:
        if dirname not in (dirnames_dst + ['node_modules']):
            print('Removing directory: {}'.format(os.path.join(dest_path, dirname)))
            shutil.rmtree(os.path.join(dest_path, dirname))

    for i, fname in enumerate(fnames):
        path_src = os.path.join(template_source_path, fname)
        path_dst = os.path.join(dest_path, fnames_dst[i])
        txt = _read_text_file(path_src)
        if do_render:
            txt2 = Template(txt).render(config)
        else:
            txt2 = txt
        num_files_processed = num_files_processed + 1
        _write_text_file_if_changed(path_dst, txt2)
    for i, dirname in enumerate(dirnames):
        if dirname not in ['node_modules', '.git']:
            num = _generate_directory(
                os.path.join(template_source_path, dirname),
                os.path.join(dest_path, dirnames_dst[i]),
                config=config,
                do_render=do_render
            )
            num_files_processed = num_files_processed + num
    return num_files_processed

def _read_text_file(fname):
    try:
        with open(fname, 'r') as f:
            return f.read()
    except:
        return ''

def _write_text_file_if_changed(fname, txt):
    if os.path.exists(fname):
        txt_existing = _read_text_file(fname)
    else:
        txt_existing = None
    if txt != txt_existing:
        print('Writing: {}'.format(fname))
        with open(fname, 'w') as f:
            f.write(txt)
    else:
        # print('Unmodified: {}'.format(fname))
        pass

def _map_file_name(fname, config):
    fname = fname.replace('{extension_name}', config['extension_name'])
    return fname

if __name__ == '__main__':
    main()